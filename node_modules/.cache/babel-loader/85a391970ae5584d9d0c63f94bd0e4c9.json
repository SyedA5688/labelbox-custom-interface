{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _reselect = require(\"reselect\");\n\nvar _warning = _interopRequireDefault(require(\"warning\"));\n\nvar _ZoomButtons = _interopRequireDefault(require(\"./ZoomButtons\"));\n\nvar _StateDebugView = _interopRequireDefault(require(\"./StateDebugView\"));\n\nvar _Utils = require(\"./Utils\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar OVERZOOM_TOLERANCE = 0.05;\nvar DOUBLE_TAP_THRESHOLD = 250;\nvar ANIMATION_SPEED = 0.1;\n\nvar isInitialized = function isInitialized(top, left, scale) {\n  return scale !== undefined && left !== undefined && top !== undefined;\n};\n\nvar imageStyle = (0, _reselect.createSelector)(function (state) {\n  return state.top;\n}, function (state) {\n  return state.left;\n}, function (state) {\n  return state.scale;\n}, function (top, left, scale) {\n  var style = {\n    cursor: 'pointer'\n  };\n  return isInitialized(top, left, scale) ? _objectSpread({}, style, {\n    transform: \"translate3d(\".concat(left, \"px, \").concat(top, \"px, 0) scale(\").concat(scale, \")\"),\n    transformOrigin: '0 0'\n  }) : style;\n});\nvar imageOverflow = (0, _reselect.createSelector)(function (state) {\n  return state.top;\n}, function (state) {\n  return state.left;\n}, function (state) {\n  return state.scale;\n}, function (state) {\n  return state.imageDimensions;\n}, function (state) {\n  return state.containerDimensions;\n}, function (top, left, scale, imageDimensions, containerDimensions) {\n  if (!isInitialized(top, left, scale)) {\n    return '';\n  }\n\n  return (0, _Utils.getImageOverflow)(top, left, scale, imageDimensions, containerDimensions);\n});\nvar browserPanActions = (0, _reselect.createSelector)(imageOverflow, function (imageOverflow) {\n  //Determine the panning directions where there is no image overflow and let\n  //the browser handle those directions (e.g., scroll viewport if possible).\n  //Need to replace 'pan-left pan-right' with 'pan-x', etc. otherwise \n  //it is rejected (o_O), therefore explicitly handle each combination.\n  var browserPanX = !imageOverflow.left && !imageOverflow.right ? 'pan-x' //we can't pan the image horizontally, let the browser take it\n  : !imageOverflow.left ? 'pan-left' : !imageOverflow.right ? 'pan-right' : '';\n  var browserPanY = !imageOverflow.top && !imageOverflow.bottom ? 'pan-y' : !imageOverflow.top ? 'pan-up' : !imageOverflow.bottom ? 'pan-down' : '';\n  return [browserPanX, browserPanY].join(' ').trim();\n}); //Ensure the image is not over-panned, and not over- or under-scaled.\n//These constraints must be checked when image changes, and when container is resized.\n\nvar PinchZoomPan = /*#__PURE__*/function (_React$Component) {\n  _inherits(PinchZoomPan, _React$Component);\n\n  function PinchZoomPan() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _classCallCheck(this, PinchZoomPan);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(PinchZoomPan)).call.apply(_getPrototypeOf2, [this].concat(args)));\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"state\", {});\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"lastPointerUpTimeStamp\", void 0);\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"lastPanPointerPosition\", void 0);\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"lastPinchLength\", void 0);\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"animation\", void 0);\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"imageRef\", void 0);\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"isImageLoaded\", void 0);\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"originalOverscrollBehaviorY\", void 0);\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"handleTouchStart\", function (event) {\n      _this.cancelAnimation();\n\n      var touches = event.touches;\n\n      if (touches.length === 2) {\n        _this.lastPinchLength = (0, _Utils.getPinchLength)(touches);\n        _this.lastPanPointerPosition = null;\n      } else if (touches.length === 1) {\n        _this.lastPinchLength = null;\n\n        _this.pointerDown(touches[0]);\n\n        (0, _Utils.tryCancelEvent)(event); //suppress mouse events\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"handleTouchMove\", function (event) {\n      var touches = event.touches;\n\n      if (touches.length === 2) {\n        _this.pinchChange(touches); //suppress viewport scaling on iOS\n\n\n        (0, _Utils.tryCancelEvent)(event);\n      } else if (touches.length === 1) {\n        var requestedPan = _this.pan(touches[0]);\n\n        if (!_this.controlOverscrollViaCss) {\n          //let the browser handling panning if we are at the edge of the image in \n          //both pan directions, or if we are primarily panning in one direction\n          //and are at the edge in that directino\n          var overflow = imageOverflow(_this.state);\n          var hasOverflowX = requestedPan.left && overflow.left > 0 || requestedPan.right && overflow.right > 0;\n          var hasOverflowY = requestedPan.up && overflow.top > 0 || requestedPan.down && overflow.bottom > 0;\n\n          if (!hasOverflowX && !hasOverflowY) {\n            //no overflow in both directions\n            return;\n          }\n\n          var panX = requestedPan.left || requestedPan.right;\n          var panY = requestedPan.up || requestedPan.down;\n\n          if (panY > 2 * panX && !hasOverflowY) {\n            //primarily panning up or down and no overflow in the Y direction\n            return;\n          }\n\n          if (panX > 2 * panY && !hasOverflowX) {\n            //primarily panning left or right and no overflow in the X direction\n            return;\n          }\n\n          (0, _Utils.tryCancelEvent)(event);\n        }\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"handleTouchEnd\", function (event) {\n      _this.cancelAnimation();\n\n      if (event.touches.length === 0 && event.changedTouches.length === 1) {\n        if (_this.lastPointerUpTimeStamp && _this.lastPointerUpTimeStamp + DOUBLE_TAP_THRESHOLD > event.timeStamp) {\n          var pointerPosition = (0, _Utils.getRelativePosition)(event.changedTouches[0], _this.imageRef.parentNode);\n\n          _this.doubleClick(pointerPosition);\n        }\n\n        _this.lastPointerUpTimeStamp = event.timeStamp;\n        (0, _Utils.tryCancelEvent)(event); //suppress mouse events\n      } //We allow transient +/-5% over-pinching.\n      //Animate the bounce back to constraints if applicable.\n\n\n      _this.maybeAdjustCurrentTransform(ANIMATION_SPEED);\n\n      return;\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"handleMouseDown\", function (event) {\n      _this.cancelAnimation();\n\n      _this.pointerDown(event);\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"handleMouseMove\", function (event) {\n      if (!event.buttons) return null;\n\n      _this.pan(event);\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"handleMouseDoubleClick\", function (event) {\n      _this.cancelAnimation();\n\n      var pointerPosition = (0, _Utils.getRelativePosition)(event, _this.imageRef.parentNode);\n\n      _this.doubleClick(pointerPosition);\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"handleMouseWheel\", function (event) {\n      _this.cancelAnimation();\n\n      var point = (0, _Utils.getRelativePosition)(event, _this.imageRef.parentNode);\n\n      if (event.deltaY > 0) {\n        if (_this.state.scale > (0, _Utils.getMinScale)(_this.state, _this.props)) {\n          _this.zoomOut(point);\n\n          (0, _Utils.tryCancelEvent)(event);\n        }\n      } else if (event.deltaY < 0) {\n        if (_this.state.scale < _this.props.maxScale) {\n          _this.zoomIn(point);\n\n          (0, _Utils.tryCancelEvent)(event);\n        }\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"handleImageLoad\", function (event) {\n      _this.debug('handleImageLoad');\n\n      _this.isImageLoaded = true;\n\n      _this.maybeHandleDimensionsChanged();\n\n      var onLoad = _react.default.Children.only(_this.props.children).props.onLoad;\n\n      if (typeof onLoad === 'function') {\n        onLoad(event);\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"handleZoomInClick\", function () {\n      _this.cancelAnimation();\n\n      _this.zoomIn();\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"handleZoomOutClick\", function () {\n      _this.cancelAnimation();\n\n      _this.zoomOut();\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"handleWindowResize\", function () {\n      return _this.maybeHandleDimensionsChanged();\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"handleRefImage\", function (ref) {\n      if (_this.imageRef) {\n        _this.cancelAnimation();\n\n        _this.imageRef.removeEventListener('touchmove', _this.handleTouchMove);\n      }\n\n      _this.imageRef = ref;\n\n      if (ref) {\n        _this.imageRef.addEventListener('touchmove', _this.handleTouchMove, {\n          passive: false\n        });\n      }\n\n      var _React$Children$only = _react.default.Children.only(_this.props.children),\n          imageRefProp = _React$Children$only.ref;\n\n      (0, _Utils.setRef)(imageRefProp, ref);\n    });\n\n    return _this;\n  }\n\n  _createClass(PinchZoomPan, [{\n    key: \"pointerDown\",\n    //actions\n    value: function pointerDown(clientPosition) {\n      this.lastPanPointerPosition = (0, _Utils.getRelativePosition)(clientPosition, this.imageRef.parentNode);\n    }\n  }, {\n    key: \"pan\",\n    value: function pan(pointerClientPosition) {\n      if (!this.isTransformInitialized) {\n        return;\n      }\n\n      if (!this.lastPanPointerPosition) {\n        //if we were pinching and lifted a finger\n        this.pointerDown(pointerClientPosition);\n        return 0;\n      }\n\n      var pointerPosition = (0, _Utils.getRelativePosition)(pointerClientPosition, this.imageRef.parentNode);\n      var translateX = pointerPosition.x - this.lastPanPointerPosition.x;\n      var translateY = pointerPosition.y - this.lastPanPointerPosition.y;\n      this.lastPanPointerPosition = pointerPosition;\n      var top = this.state.top + translateY;\n      var left = this.state.left + translateX;\n      this.constrainAndApplyTransform(top, left, this.state.scale, 0, 0);\n      return {\n        up: translateY > 0 ? translateY : 0,\n        down: translateY < 0 ? (0, _Utils.negate)(translateY) : 0,\n        right: translateX < 0 ? (0, _Utils.negate)(translateX) : 0,\n        left: translateX > 0 ? translateX : 0\n      };\n    }\n  }, {\n    key: \"doubleClick\",\n    value: function doubleClick(pointerPosition) {\n      if (String(this.props.doubleTapBehavior).toLowerCase() === 'zoom' && this.state.scale * (1 + OVERZOOM_TOLERANCE) < this.props.maxScale) {\n        this.zoomIn(pointerPosition, ANIMATION_SPEED, 0.3);\n      } else {\n        //reset\n        this.applyInitialTransform(ANIMATION_SPEED);\n      }\n    }\n  }, {\n    key: \"pinchChange\",\n    value: function pinchChange(touches) {\n      var length = (0, _Utils.getPinchLength)(touches);\n      var midpoint = (0, _Utils.getPinchMidpoint)(touches);\n      var scale = this.lastPinchLength ? this.state.scale * length / this.lastPinchLength //sometimes we get a touchchange before a touchstart when pinching\n      : this.state.scale;\n      this.zoom(scale, midpoint, OVERZOOM_TOLERANCE);\n      this.lastPinchLength = length;\n    }\n  }, {\n    key: \"zoomIn\",\n    value: function zoomIn(midpoint) {\n      var speed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var factor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.1;\n      midpoint = midpoint || {\n        x: this.state.containerDimensions.width / 2,\n        y: this.state.containerDimensions.height / 2\n      };\n      this.zoom(this.state.scale * (1 + factor), midpoint, 0, speed);\n    }\n  }, {\n    key: \"zoomOut\",\n    value: function zoomOut(midpoint) {\n      midpoint = midpoint || {\n        x: this.state.containerDimensions.width / 2,\n        y: this.state.containerDimensions.height / 2\n      };\n      this.zoom(this.state.scale * 0.9, midpoint, 0);\n    }\n  }, {\n    key: \"zoom\",\n    value: function zoom(requestedScale, containerRelativePoint, tolerance) {\n      var speed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n      if (!this.isTransformInitialized) {\n        return;\n      }\n\n      var _this$state = this.state,\n          scale = _this$state.scale,\n          top = _this$state.top,\n          left = _this$state.left;\n      var imageRelativePoint = {\n        top: containerRelativePoint.y - top,\n        left: containerRelativePoint.x - left\n      };\n      var nextScale = this.getConstrainedScale(requestedScale, tolerance);\n      var incrementalScalePercentage = (nextScale - scale) / scale;\n      var translateY = imageRelativePoint.top * incrementalScalePercentage;\n      var translateX = imageRelativePoint.left * incrementalScalePercentage;\n      var nextTop = top - translateY;\n      var nextLeft = left - translateX;\n      this.constrainAndApplyTransform(nextTop, nextLeft, nextScale, tolerance, speed);\n    } //compare stored dimensions to actual dimensions; capture actual dimensions if different\n\n  }, {\n    key: \"maybeHandleDimensionsChanged\",\n    value: function maybeHandleDimensionsChanged() {\n      var _this2 = this;\n\n      if (this.isImageReady) {\n        var containerDimensions = (0, _Utils.getContainerDimensions)(this.imageRef);\n        var imageDimensions = (0, _Utils.getDimensions)(this.imageRef);\n\n        if (!(0, _Utils.isEqualDimensions)(containerDimensions, (0, _Utils.getDimensions)(this.state.containerDimensions)) || !(0, _Utils.isEqualDimensions)(imageDimensions, (0, _Utils.getDimensions)(this.state.imageDimensions))) {\n          this.cancelAnimation(); //capture new dimensions\n\n          this.setState({\n            containerDimensions: containerDimensions,\n            imageDimensions: imageDimensions\n          }, function () {\n            //When image loads and image dimensions are first established, apply initial transform.\n            //If dimensions change, constraints change; current transform may need to be adjusted.\n            //Transforms depend on state, so wait until state is updated.\n            if (!_this2.isTransformInitialized) {\n              _this2.applyInitialTransform();\n            } else {\n              _this2.maybeAdjustCurrentTransform();\n            }\n          });\n          this.debug(\"Dimensions changed: Container: \".concat(containerDimensions.width, \", \").concat(containerDimensions.height, \", Image: \").concat(imageDimensions.width, \", \").concat(imageDimensions.height));\n        }\n      } else {\n        this.debug('Image not loaded');\n      }\n    } //transformation methods\n    //Zooming and panning cause transform to be requested.\n\n  }, {\n    key: \"constrainAndApplyTransform\",\n    value: function constrainAndApplyTransform(requestedTop, requestedLeft, requestedScale, tolerance) {\n      var speed = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n      var requestedTransform = {\n        top: requestedTop,\n        left: requestedLeft,\n        scale: requestedScale\n      };\n      this.debug(\"Requesting transform: left \".concat(requestedLeft, \", top \").concat(requestedTop, \", scale \").concat(requestedScale)); //Correct the transform if needed to prevent overpanning and overzooming\n\n      var transform = this.getCorrectedTransform(requestedTransform, tolerance) || requestedTransform;\n      this.debug(\"Applying transform: left \".concat(transform.left, \", top \").concat(transform.top, \", scale \").concat(transform.scale));\n\n      if ((0, _Utils.isEqualTransform)(transform, this.state)) {\n        return false;\n      }\n\n      this.applyTransform(transform, speed);\n      return true;\n    }\n  }, {\n    key: \"applyTransform\",\n    value: function applyTransform(_ref, speed) {\n      var _this3 = this;\n\n      var top = _ref.top,\n          left = _ref.left,\n          scale = _ref.scale;\n\n      if (speed > 0) {\n        var frame = function frame() {\n          var translateY = top - _this3.state.top;\n          var translateX = left - _this3.state.left;\n          var translateScale = scale - _this3.state.scale;\n          var nextTransform = {\n            top: (0, _Utils.snapToTarget)(_this3.state.top + speed * translateY, top, 1),\n            left: (0, _Utils.snapToTarget)(_this3.state.left + speed * translateX, left, 1),\n            scale: (0, _Utils.snapToTarget)(_this3.state.scale + speed * translateScale, scale, 0.001)\n          }; //animation runs until we reach the target\n\n          if (!(0, _Utils.isEqualTransform)(nextTransform, _this3.state)) {\n            _this3.setState(nextTransform, function () {\n              return _this3.animation = requestAnimationFrame(frame);\n            });\n          }\n        };\n\n        this.animation = requestAnimationFrame(frame);\n      } else {\n        this.setState({\n          top: top,\n          left: left,\n          scale: scale\n        });\n      }\n    } //Returns constrained scale when requested scale is outside min/max with tolerance, otherwise returns requested scale\n\n  }, {\n    key: \"getConstrainedScale\",\n    value: function getConstrainedScale(requestedScale, tolerance) {\n      var lowerBoundFactor = 1.0 - tolerance;\n      var upperBoundFactor = 1.0 + tolerance;\n      return (0, _Utils.constrain)((0, _Utils.getMinScale)(this.state, this.props) * lowerBoundFactor, this.props.maxScale * upperBoundFactor, requestedScale);\n    } //Returns constrained transform when requested transform is outside constraints with tolerance, otherwise returns null\n\n  }, {\n    key: \"getCorrectedTransform\",\n    value: function getCorrectedTransform(requestedTransform, tolerance) {\n      var scale = this.getConstrainedScale(requestedTransform.scale, tolerance); //get dimensions by which scaled image overflows container\n\n      var negativeSpace = this.calculateNegativeSpace(scale);\n      var overflow = {\n        width: Math.max(0, (0, _Utils.negate)(negativeSpace.width)),\n        height: Math.max(0, (0, _Utils.negate)(negativeSpace.height))\n      }; //if image overflows container, prevent moving by more than the overflow\n      //example: overflow.height = 100, tolerance = 0.05 => top is constrained between -105 and +5\n\n      var _this$props = this.props,\n          position = _this$props.position,\n          initialTop = _this$props.initialTop,\n          initialLeft = _this$props.initialLeft;\n      var _this$state2 = this.state,\n          imageDimensions = _this$state2.imageDimensions,\n          containerDimensions = _this$state2.containerDimensions;\n      var upperBoundFactor = 1.0 + tolerance;\n      var top = overflow.height ? (0, _Utils.constrain)((0, _Utils.negate)(overflow.height) * upperBoundFactor, overflow.height * upperBoundFactor - overflow.height, requestedTransform.top) : position === 'center' ? (containerDimensions.height - imageDimensions.height * scale) / 2 : initialTop || 0;\n      var left = overflow.width ? (0, _Utils.constrain)((0, _Utils.negate)(overflow.width) * upperBoundFactor, overflow.width * upperBoundFactor - overflow.width, requestedTransform.left) : position === 'center' ? (containerDimensions.width - imageDimensions.width * scale) / 2 : initialLeft || 0;\n      var constrainedTransform = {\n        top: top,\n        left: left,\n        scale: scale\n      };\n      return (0, _Utils.isEqualTransform)(constrainedTransform, requestedTransform) ? null : constrainedTransform;\n    } //Ensure current transform is within constraints\n\n  }, {\n    key: \"maybeAdjustCurrentTransform\",\n    value: function maybeAdjustCurrentTransform() {\n      var speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var correctedTransform;\n\n      if (correctedTransform = this.getCorrectedTransform(this.state, 0)) {\n        this.applyTransform(correctedTransform, speed);\n      }\n    }\n  }, {\n    key: \"applyInitialTransform\",\n    value: function applyInitialTransform() {\n      var speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var _this$state3 = this.state,\n          imageDimensions = _this$state3.imageDimensions,\n          containerDimensions = _this$state3.containerDimensions;\n      var _this$props2 = this.props,\n          position = _this$props2.position,\n          initialScale = _this$props2.initialScale,\n          maxScale = _this$props2.maxScale,\n          initialTop = _this$props2.initialTop,\n          initialLeft = _this$props2.initialLeft;\n      var scale = String(initialScale).toLowerCase() === 'auto' ? (0, _Utils.getAutofitScale)(containerDimensions, imageDimensions) : initialScale;\n      var minScale = (0, _Utils.getMinScale)(this.state, this.props);\n\n      if (minScale > maxScale) {\n        (0, _warning.default)(false, 'minScale cannot exceed maxScale.');\n        return;\n      }\n\n      if (scale < minScale || scale > maxScale) {\n        (0, _warning.default)(false, 'initialScale must be between minScale and maxScale.');\n        return;\n      }\n\n      var initialPosition;\n\n      if (position === 'center') {\n        (0, _warning.default)(initialTop === undefined, 'initialTop prop should not be supplied with position=center. It was ignored.');\n        (0, _warning.default)(initialLeft === undefined, 'initialLeft prop should not be supplied with position=center. It was ignored.');\n        initialPosition = {\n          top: (containerDimensions.width - imageDimensions.width * scale) / 2,\n          left: (containerDimensions.height - imageDimensions.height * scale) / 2\n        };\n      } else {\n        initialPosition = {\n          top: initialTop || 0,\n          left: initialLeft || 0\n        };\n      }\n\n      this.constrainAndApplyTransform(initialPosition.top, initialPosition.left, scale, 0, speed);\n    } //lifecycle methods\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      var childElement = _react.default.Children.only(this.props.children);\n\n      var _this$props3 = this.props,\n          zoomButtons = _this$props3.zoomButtons,\n          maxScale = _this$props3.maxScale,\n          debug = _this$props3.debug;\n      var scale = this.state.scale;\n      var touchAction = this.controlOverscrollViaCss ? browserPanActions(this.state) || 'none' : undefined;\n      var containerStyle = {\n        width: '100%',\n        height: '100%',\n        overflow: 'hidden',\n        touchAction: touchAction\n      };\n      return _react.default.createElement(\"div\", {\n        style: containerStyle\n      }, zoomButtons && this.isImageReady && this.isTransformInitialized && _react.default.createElement(_ZoomButtons.default, {\n        scale: scale,\n        minScale: (0, _Utils.getMinScale)(this.state, this.props),\n        maxScale: maxScale,\n        onZoomOutClick: this.handleZoomOutClick,\n        onZoomInClick: this.handleZoomInClick\n      }), debug && _react.default.createElement(_StateDebugView.default, _extends({}, this.state, {\n        overflow: imageOverflow(this.state)\n      })), _react.default.cloneElement(childElement, {\n        onTouchStart: this.handleTouchStart,\n        onTouchEnd: this.handleTouchEnd,\n        onMouseDown: this.handleMouseDown,\n        onMouseMove: this.handleMouseMove,\n        onDoubleClick: this.handleMouseDoubleClick,\n        onWheel: this.handleMouseWheel,\n        onDragStart: _Utils.tryCancelEvent,\n        onLoad: this.handleImageLoad,\n        onContextMenu: _Utils.tryCancelEvent,\n        ref: this.handleRefImage,\n        style: imageStyle(this.state)\n      }));\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      window.addEventListener(\"resize\", this.handleWindowResize);\n      this.maybeHandleDimensionsChanged();\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState) {\n      this.maybeHandleDimensionsChanged();\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.cancelAnimation();\n      this.imageRef.removeEventListener('touchmove', this.handleTouchMove);\n      window.removeEventListener('resize', this.handleWindowResize);\n    }\n  }, {\n    key: \"calculateNegativeSpace\",\n    value: function calculateNegativeSpace(scale) {\n      //get difference in dimension between container and scaled image\n      var _this$state4 = this.state,\n          containerDimensions = _this$state4.containerDimensions,\n          imageDimensions = _this$state4.imageDimensions;\n      var width = containerDimensions.width - scale * imageDimensions.width;\n      var height = containerDimensions.height - scale * imageDimensions.height;\n      return {\n        width: width,\n        height: height\n      };\n    }\n  }, {\n    key: \"cancelAnimation\",\n    value: function cancelAnimation() {\n      if (this.animation) {\n        cancelAnimationFrame(this.animation);\n      }\n    }\n  }, {\n    key: \"debug\",\n    value: function debug(message) {\n      if (this.props.debug) {\n        console.log(message);\n      }\n    }\n  }, {\n    key: \"isImageReady\",\n    get: function get() {\n      return this.isImageLoaded || this.imageRef && this.imageRef.tagName !== 'IMG';\n    }\n  }, {\n    key: \"isTransformInitialized\",\n    get: function get() {\n      return isInitialized(this.state.top, this.state.left, this.state.scale);\n    }\n  }, {\n    key: \"controlOverscrollViaCss\",\n    get: function get() {\n      return window.CSS && window.CSS.supports('touch-action', 'pan-up');\n    }\n  }], [{\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(nextProps, prevState) {\n      if (nextProps.initialTop !== prevState.initialTop || nextProps.initialLeft !== prevState.initialLeft || nextProps.initialScale !== prevState.initialScale || nextProps.position !== prevState.position) {\n        return {\n          position: nextProps.position,\n          initialScale: nextProps.initialScale,\n          initialTop: nextProps.initialTop,\n          initialLeft: nextProps.initialLeft\n        };\n      } else {\n        return null;\n      }\n    }\n  }]);\n\n  return PinchZoomPan;\n}(_react.default.Component);\n\nexports.default = PinchZoomPan;\nPinchZoomPan.defaultProps = {\n  initialScale: 'auto',\n  minScale: 'auto',\n  maxScale: 1,\n  position: 'topLeft',\n  zoomButtons: true,\n  doubleTapBehavior: 'reset'\n};\nPinchZoomPan.propTypes = {\n  children: _propTypes.default.element.isRequired,\n  initialScale: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string]),\n  minScale: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string]),\n  maxScale: _propTypes.default.number,\n  position: _propTypes.default.oneOf(['topLeft', 'center']),\n  zoomButtons: _propTypes.default.bool,\n  doubleTapBehavior: _propTypes.default.oneOf(['reset', 'zoom']),\n  initialTop: _propTypes.default.number,\n  initialLeft: _propTypes.default.number\n};","map":null,"metadata":{},"sourceType":"script"}