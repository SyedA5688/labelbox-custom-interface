{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setRef = setRef;\nexports.getRequiredImagePosition = exports.getImageOverflow = exports.tryCancelEvent = exports.getMinScale = exports.getAutofitScale = exports.isEqualTransform = exports.getContainerDimensions = exports.getDimensions = exports.isEqualDimensions = exports.getPinchLength = exports.getPinchMidpoint = exports.getRelativePosition = exports.negate = exports.constrain = exports.snapToTarget = void 0;\n\nvar _reselect = require(\"reselect\");\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nvar snapToTarget = function snapToTarget(value, target, tolerance) {\n  var withinRange = Math.abs(target - value) < tolerance;\n  return withinRange ? target : value;\n};\n\nexports.snapToTarget = snapToTarget;\n\nvar constrain = function constrain(lowerBound, upperBound, value) {\n  return Math.min(upperBound, Math.max(lowerBound, value));\n};\n\nexports.constrain = constrain;\n\nvar negate = function negate(value) {\n  return value * -1;\n};\n\nexports.negate = negate;\n\nvar getRelativePosition = function getRelativePosition(_ref, relativeToElement) {\n  var clientX = _ref.clientX,\n      clientY = _ref.clientY;\n  var rect = relativeToElement.getBoundingClientRect();\n  return {\n    x: clientX - rect.left,\n    y: clientY - rect.top\n  };\n};\n\nexports.getRelativePosition = getRelativePosition;\n\nvar getPinchMidpoint = function getPinchMidpoint(_ref2) {\n  var _ref3 = _slicedToArray(_ref2, 2),\n      touch1 = _ref3[0],\n      touch2 = _ref3[1];\n\n  return {\n    x: (touch1.clientX + touch2.clientX) / 2,\n    y: (touch1.clientY + touch2.clientY) / 2\n  };\n};\n\nexports.getPinchMidpoint = getPinchMidpoint;\n\nvar getPinchLength = function getPinchLength(_ref4) {\n  var _ref5 = _slicedToArray(_ref4, 2),\n      touch1 = _ref5[0],\n      touch2 = _ref5[1];\n\n  return Math.sqrt(Math.pow(touch1.clientY - touch2.clientY, 2) + Math.pow(touch1.clientX - touch2.clientX, 2));\n};\n\nexports.getPinchLength = getPinchLength;\n\nfunction setRef(ref, value) {\n  if (typeof ref === 'function') {\n    ref(value);\n  } else if (ref) {\n    ref.current = value;\n  }\n}\n\n;\n\nvar isEqualDimensions = function isEqualDimensions(dimensions1, dimensions2) {\n  if (dimensions1 === dimensions2 === undefined) {\n    return true;\n  }\n\n  if (dimensions1 === undefined || dimensions2 === undefined) {\n    return false;\n  }\n\n  return dimensions1.width === dimensions2.width && dimensions1.height === dimensions2.height;\n};\n\nexports.isEqualDimensions = isEqualDimensions;\n\nvar getDimensions = function getDimensions(object) {\n  if (object === undefined) {\n    return undefined;\n  }\n\n  return {\n    width: object.offsetWidth || object.width,\n    height: object.offsetHeight || object.height\n  };\n};\n\nexports.getDimensions = getDimensions;\n\nvar getContainerDimensions = function getContainerDimensions(image) {\n  return {\n    width: image.parentNode.offsetWidth,\n    height: image.parentNode.offsetHeight\n  };\n};\n\nexports.getContainerDimensions = getContainerDimensions;\n\nvar isEqualTransform = function isEqualTransform(transform1, transform2) {\n  if (transform1 === transform2 === undefined) {\n    return true;\n  }\n\n  if (transform1 === undefined || transform2 === undefined) {\n    return false;\n  }\n\n  return round(transform1.top, 5) === round(transform2.top, 5) && round(transform1.left, 5) === round(transform2.left, 5) && round(transform1.scale, 5) === round(transform2.scale, 5);\n};\n\nexports.isEqualTransform = isEqualTransform;\n\nvar getAutofitScale = function getAutofitScale(containerDimensions, imageDimensions) {\n  var _ref6 = imageDimensions || {},\n      imageWidth = _ref6.width,\n      imageHeight = _ref6.height;\n\n  if (!(imageWidth > 0 && imageHeight > 0)) {\n    return 1;\n  }\n\n  return Math.min(containerDimensions.width / imageWidth, containerDimensions.height / imageHeight, 1);\n};\n\nexports.getAutofitScale = getAutofitScale;\nvar getMinScale = (0, _reselect.createSelector)(function (state) {\n  return state.containerDimensions;\n}, function (state) {\n  return state.imageDimensions;\n}, function (state, props) {\n  return props.minScale;\n}, function (containerDimensions, imageDimensions, minScaleProp) {\n  return String(minScaleProp).toLowerCase() === 'auto' ? getAutofitScale(containerDimensions, imageDimensions) : minScaleProp || 1;\n});\nexports.getMinScale = getMinScale;\n\nfunction round(number, precision) {\n  if (precision && number !== null && number !== undefined) {\n    // Shift with exponential notation to avoid floating-point issues.\n    // See [MDN](https://mdn.io/round#Examples) for more details.\n    var pair = (String(number) + 'e').split('e'),\n        value = Math.round(pair[0] + 'e' + (+pair[1] + precision));\n    pair = (String(value) + 'e').split('e');\n    return +(pair[0] + 'e' + (+pair[1] - precision));\n  }\n\n  return Math.round(number);\n}\n\n;\n\nvar tryCancelEvent = function tryCancelEvent(event) {\n  if (event.cancelable === false) {\n    return false;\n  }\n\n  event.preventDefault();\n  return true;\n};\n\nexports.tryCancelEvent = tryCancelEvent;\n\nfunction calculateOverflowLeft(left, scale, imageDimensions, containerDimensions) {\n  var overflow = negate(left);\n  return overflow > 0 ? overflow : 0;\n}\n\nfunction calculateOverflowTop(top, scale, imageDimensions, containerDimensions) {\n  var overflow = negate(top);\n  return overflow > 0 ? overflow : 0;\n}\n\nfunction calculateOverflowRight(left, scale, imageDimensions, containerDimensions) {\n  var overflow = Math.max(0, scale * imageDimensions.width - containerDimensions.width);\n  return overflow > 0 ? overflow - negate(left) : 0;\n}\n\nfunction calculateOverflowBottom(top, scale, imageDimensions, containerDimensions) {\n  var overflow = Math.max(0, scale * imageDimensions.height - containerDimensions.height);\n  return overflow > 0 ? overflow - negate(top) : 0;\n}\n\nvar getImageOverflow = function getImageOverflow(top, left, scale, imageDimensions, containerDimensions) {\n  return {\n    top: calculateOverflowTop(top, scale, imageDimensions, containerDimensions),\n    right: calculateOverflowRight(left, scale, imageDimensions, containerDimensions),\n    bottom: calculateOverflowBottom(top, scale, imageDimensions, containerDimensions),\n    left: calculateOverflowLeft(left, scale, imageDimensions, containerDimensions)\n  };\n};\n\nexports.getImageOverflow = getImageOverflow;\n\nvar getRequiredImagePosition = function getRequiredImagePosition(position, scale, imageDimensions, containerDimensions) {\n  var overflow = getImageOverflow();\n};\n\nexports.getRequiredImagePosition = getRequiredImagePosition;","map":null,"metadata":{},"sourceType":"script"}